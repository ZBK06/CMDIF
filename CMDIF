// 1. Load datasets
var dw = ee.ImageCollection("GOOGLE/DYNAMICWORLD/V1");
var esa = ee.ImageCollection("ESA/WorldCover/v200");
var jrc_month = ee.ImageCollection("JRC/GSW1_4/MonthlyHistory");
var dem = ee.Image("USGS/SRTMGL1_003");
var ghsl = ee.Image('JRC/GHSL/P2023A/GHS_BUILT_S_10m/2018').select('built_surface');
var jrc_gsw = ee.Image('JRC/GSW1_4/GlobalSurfaceWater');
var S2 = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");
var S1 = ee.ImageCollection('COPERNICUS/S1_GRD');

// 2. Define Region of Interest (ROI)
var roi = ee.Geometry.Polygon(
  [[[32.81201278251589, 1.7035206744239066],
    [32.81201278251589, 1.272453722443622],
    [33.32287704032839, 1.272453722443622],
    [33.32287704032839, 1.7035206744239066]]], null, false);

// 3. Sample generation (Part 1)
var S2bands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B8A', 'B9', 'B11', 'B12'];
var year = 2021;
var month = 11;
var startDate = ee.Date.fromYMD(year, month, 1);
var endDate = startDate.advance(1, 'month');

// 4. Load and process Sentinel-2 data
var S2_image = S2.filterBounds(roi)
  .filterDate(startDate, endDate)
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20))
  .map(maskS2clouds)
  .select(S2bands)
  .map(S2addIndices)
  .map(function(image) { return image.clip(roi); });

var S2_median = S2_image.median();
print('S2_median for month:', month, S2_median);

// 5. Calculate texture features using GLCM
var glcmParams = {size: 3, average: true};
var ndviTexture = S2_median.select('ndvi').unitScale(-1, 1).multiply(255).toByte().glcmTexture(glcmParams);
var ndwiTexture = S2_median.select('mNDWI').unitScale(-1, 1).multiply(255).toByte().glcmTexture(glcmParams);

// 6. Extract terrain features
var terrain = ee.Terrain.products(dem);
var slope = terrain.select('slope');
var aspect = terrain.select('aspect');

// 7. Load Dynamic World data and remap
var dwComposite = ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1')
  .filterDate(startDate, endDate)
  .filterBounds(roi)
  .select('label')
  .reduce(ee.Reducer.mode())
  .clip(roi);

var dwCompositeRemapped = dwComposite.remap([0,1,2,3,4,5,6,7,8],[0,1,1,1,1,1,2,3,4]).rename('landcover');

// 8. Combine Sentinel-2, Dynamic World, and texture features
var S2Features = S2_median.addBands(dwCompositeRemapped)
  .addBands(ndwiTexture.select(['mNDWI_contrast', 'mNDWI_diss', 'mNDWI_ent', 'mNDWI_asm', 'mNDWI_savg', 'mNDWI_var', 'mNDWI_idm', 'mNDWI_corr']))
  .addBands(ndviTexture.select(['ndvi_contrast', 'ndvi_diss', 'ndvi_ent', 'ndvi_asm', 'ndvi_savg', 'ndvi_var', 'ndvi_idm', 'ndvi_corr']))
  .addBands(slope)
  .addBands(aspect);

// 9. Stratified sampling
var stratifiedSample = S2Features.stratifiedSample({
  numPoints: 1200,
  classBand: 'landcover',
  region: roi,
  scale: 10,
  geometries: true
});
print('Stratified Sample for month:', month, stratifiedSample);

// 10. Visualize and export sample points
Map.addLayer(S2_median, {bands: ['B8', 'B3', 'B2'], min: 0, max: 0.3}, 'S2_resampled_' + month);
Map.addLayer(stratifiedSample, {color: 'red', pointSize: 5}, 'Sample Landcover ' + month);

Export.table.toDrive({
  collection: stratifiedSample,
  description: 'S2Expert_' + year + '_' + month,
  fileFormat: 'SHP'
});

// 11. Part 2 - Optical Image Random Forest Classification
var alldata = stratifiedSample.randomColumn('random');
var training_samples = alldata.filter(ee.Filter.lte('random', 0.7));
var test_samples = alldata.filter(ee.Filter.gte('random', 0.7));
print("Training Samples:", training_samples);
print("Test Samples:", test_samples);

// 12. Train Random Forest Classifier
var classifier = ee.Classifier.smileRandomForest(100).train({
  features: training_samples,
  classProperty: 'landcover',
  inputProperties: S2bands
});
var classified = S2_median.classify(classifier);
var VIS_PALETTE = ['blue', 'green', 'red', 'yellow', 'white'];

// 13. Remap the classification results
var updated_classified = classified.remap([0, 1, 2, 3, 4], [1, 2, 3, 4, 5]);
Map.addLayer(updated_classified, {min: 1, max: 5, palette: VIS_PALETTE}, 'Landcover Updated');

// 14. Part 3 - Sentinel-1 Water Body Extraction
var s1Collection = S1.filterBounds(roi)
  .filterDate('2021-11-01', '2021-12-01')
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  .filter(ee.Filter.eq('instrumentMode', 'IW'));

// 15. Calculate SDWI for Sentinel-1
var s1SDWI = s1Collection.map(S1addIndices).select("SDWI");
var sdwiComposite = s1SDWI.median().clip(roi);

// 16. Perform SNIC segmentation
var segmentation = ee.Algorithms.Image.Segmentation.SNIC({
  image: sdwiComposite,
  size: 14,
  compactness: 0.1,
  connectivity: 8
}).select(['SDWI_mean', 'clusters'], ['SDWI', 'clusters']);

// 17. Edge detection and classification using Otsu thresholding
var biocut = segmentation.select('SDWI').gte(0.59);
var canny = ee.Algorithms.CannyEdgeDetector(biocut, 1, 1);
var connected = canny.updateMask(canny).lt(0.05).connectedPixelCount(500, true);
var edges = connected.gte(5);
var edgeBuffer = edges.focal_max(5, 'square', 'meters');
var histogram_image = segmentation.select('SDWI').updateMask(edgeBuffer);
var histogram_ = histogram_image.select('SDWI').reduceRegion({
  reducer: ee.Reducer.histogram(255, 0.25),
  geometry: roi,
  scale: 10,
  bestEffort: true
});
var threshold1 = otsu(histogram_.get('SDWI'));
var waterImgPre = ee.Image(ee.Algorithms.If(false, segmentation.lt(threshold1), segmentation.gt(threshold1))).selfMask().clip(roi);
var waterImg = waterImgPre.select('SDWI').unmask(0);
Map.addLayer(waterImg, {min: 0, max: 1, palette: ['white', 'blue']}, 'Water Img');

// 18. Part 4 - Hierarchical Decision Tree
var dwComposite = ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1')
  .filterDate('2019-01-01', '2022-01-01')
  .filterBounds(roi)
  .select('label')
  .map(function(image) {
    return image.remap([0, 1, 2, 3, 4, 5, 6, 7, 8], [1, 0, 0, 0, 0, 0, 0, 0, 0]).clip(roi).unmask(0);
  });
var waterFrequency = dwComposite.reduce(ee.Reducer.mean())
  .clip(roi)
  .multiply(100)
  .rename('Water Frequency');
var maxWaterExtent = waterFrequency.gte(5);
Map.addLayer(maxWaterExtent, {min: 0, max: 1, palette: ['white', 'blue']}, 'Max Water Extent');

// 19. Final Water Mask Integration and Export
var valid_water = waterImg.or(updated_classified.eq(1))
  .where(waterImg.or(updated_classified.eq(1)).not(), 0);
var final_water = valid_water.updateMask(maxWaterExtent).unmask(0).clip(roi);
Map.addLayer(final_water, {min: 0, max: 1, palette: ['ffffff', '0000ff']}, 'Final Water Mask');

Export.image.toDrive({
  image: final_water,
  description: 'Final_Water_Mask',
  fileNamePrefix: 'Final_Water_Mask',
  region: roi,
  scale: 10,
  maxPixels: 1e13,
  fileFormat: 'GeoTIFF'
});

// 20. Supporting functions
function S2addIndices(image) {
  // Indices for water bodies and vegetation (LSWI, NDWI, etc.)
  var lswi = image.normalizedDifference(['B8', 'B12']).rename('LSWI');
  var mndwi = image.normalizedDifference(['B3', 'B11']).rename('mNDWI');
  var ndwi = image.normalizedDifference(['B3', 'B8']).rename('NDWI');
  return image.addBands([lswi, mndwi, ndwi]);
}

function maskS2clouds(image) {
  var qa = image.select('QA60');
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0).and(qa.bitwiseAnd(cirrusBitMask).eq(0));
  return image.updateMask(mask).divide(10000);
}

function S1addIndices(image) {
  var vv = image.select('VV');
  var vh = image.select('VH');
  var SDWI = image.expression('log(10*VV*VH)-8', {'VV': vv, 'VH': vh}).rename('SDWI');
  return image.addBands([SDWI]);
}

function otsu(histogram) {
  var counts = ee.Array(ee.Dictionary(histogram).get('histogram'));
  var means = ee.Array(ee.Dictionary(histogram).get('bucketMeans'));
  var total = counts.reduce(ee.Reducer.sum(), [0]).get([0]);
  var sum = means.multiply(counts).reduce(ee.Reducer.sum(), [0]).get([0]);
  var mean = sum.divide(total);
  var indices = ee.List.sequence(1, means.length().get([0]));
  var bss = indices.map(function(i) {
    var aCounts = counts.slice(0, 0, i);
    var aCount = aCounts.reduce(ee.Reducer.sum(), [0]).get([0]);
    var aMeans = means.slice(0, 0, i);
    var aMean = aMeans.multiply(aCounts).reduce(ee.Reducer.sum(), [0]).get([0]).divide(aCount);
    var bCount = total.subtract(aCount);
    var bMean = sum.subtract(aCount.multiply(aMean)).divide(bCount);
    return aCount.multiply(aMean.subtract(mean).pow(2)).add(bCount.multiply(bMean.subtract(mean).pow(2)));
  });
  return means.sort(bss).get([-1]);
}
